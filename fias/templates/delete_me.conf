source fias
{
    type                = pgsql
    sql_host            = 127.0.0.1
    sql_user            = postgres
    sql_pass            =
    sql_db              = fias
    sql_port            = 5432
}

source addrobj: fias
{
    sql_query_pre             = CREATE TEMPORARY SEQUENCE fias_addrobj_id_seq;
    sql_query_post            = DROP SEQUENCE IF EXISTS fias_addrobj_id_seq;

    sql_query           = WITH RECURSIVE PATH (docid, aoguid, aolevel, scname, fullname) AS (\
  SELECT NEXTVAL('fias_addrobj_id_seq') AS docid, ao.aoguid, ao.aolevel,\
    (SELECT sn.socrname FROM fias_socrbase AS sn WHERE sn.scname=ao.shortname AND sn.level=ao.aolevel)::text AS scname,\
    ao.shortname || ' ' || formalname AS fullname\
  FROM fias_addrobj AS ao\
  WHERE aolevel = 1 AND livestatus = TRUE\
  UNION\
  SELECT NEXTVAL('fias_addrobj_id_seq') AS docid, child.aoguid, child.aolevel,\
PATH.scname::text || ', ' || (SELECT sn.socrname FROM fias_socrbase AS sn WHERE sn.scname=child.shortname AND sn.level=child.aolevel) AS scname,\
    PATH.fullname || ', ' || child.shortname || ' ' || child.formalname AS fullname\
  FROM fias_addrobj AS child, PATH\
  WHERE child.parentguid = PATH.aoguid AND livestatus = TRUE\
)\
SELECT * FROM PATH;


    sql_field_string = fullname
    sql_attr_string = aoguid
    sql_attr_uint   = aolevel
}

index fias
{
    type                = plain
    docinfo             = extern
    morphology          = stem_ru
    min_stemming_len    = 2

    stopwords           =
    min_word_len        = 2
    charset_type        = utf-8
    min_prefix_len      = 1
    min_infix_len       = 0
    enable_star         = 1

    # strip html by default
    html_strip          = 1

    ignore_chars        = @, -
}

index addrobj: fias
{
    source              = addrobj
    path                = /var/calculate/www/data/v3d.tst/sphinx/fias_addrobj
}

indexer
{
        # memory limit, in bytes, kiloytes (16384K) or megabytes (256M)
        # optional, default is 32M, max is 2047M, recommended is 256M to 1024M
        mem_limit               = 256M

        # maximum IO calls per second (for I/O throttling)
        # optional, default is 0 (unlimited)
        #
        # max_iops              = 40

        # maximum IO call size, bytes (for I/O throttling)
        # optional, default is 0 (unlimited)
        #
        max_iosize              = 524288
}

searchd
{

        listen                  = 127.0.0.1:9306:mysql41

        # required by RT-indexes
        workers                 = threads

        # log file, searchd run info is logged here
        # optional, default is 'searchd.log'
        log                     = /var/log/sphinx/searchd.log

        # query log file, all search queries are logged here
        # optional, default is empty (do not log queries)
        query_log               = /var/log/sphinx/query.log

        # client read timeout, seconds
        # optional, default is 5
        read_timeout    = 5

        # maximum amount of children to fork (concurrent searches to run)
        # optional, default is 0 (unlimited)
        max_children    = 30

        # PID file, searchd process ID file name
        # mandatory
        pid_file                = /var/run/searchd.pid

        # max amount of matches the daemon ever keeps in RAM, per-index
        # WARNING, THERE'S ALSO PER-QUERY LIMIT, SEE SetLimits() API CALL
        # default is 1000 (just like Google)
        max_matches             = 1000

        # seamless rotate, prevents rotate stalls if precaching huge datasets
        # optional, default is 1
        seamless_rotate = 1

        # whether to forcibly preopen all indexes on startup
        # optional, default is 0 (do not preopen)
        preopen_indexes = 0

        # whether to unlink .old index copies on succesful rotation.
        # optional, default is 1 (do unlink)
        unlink_old              = 1


        # http://sphinxsearch.com/docs/2.0.6/conf-compat-sphinxql-magics.html
        compat_sphinxql_magics = 0
}